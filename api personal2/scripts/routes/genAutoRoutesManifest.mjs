/**
 * scripts/routes/genAutoRoutesManifest.mjs
 *
 * Genera un manifest tipado con rutas auto-montables a partir de:
 *   src/routes/auto/**\/*.routes.ts
 *
 * Cada archivo .routes.ts debe exportar:
 *   - basePath: string
 *   - buildRouter(ctx): Router
 *
 * Este script NO modifica rutas existentes del proyecto: solo crea/actualiza:
 *   - src/routes/auto/auto.manifest.ts
 *
 * Importante:
 * - El manifest siempre se genera como AutoRouteEntry[] (aunque esté vacío)
 *   para evitar inferencias "never[]" en TS y errores como entry.load().
 */

import fs from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Repo root: .../scripts/routes -> subimos 2 niveles
const ROOT = path.resolve(__dirname, "..", "..");

// Paths
const SRC_DIR = path.join(ROOT, "src");
const AUTO_DIR = path.join(SRC_DIR, "routes", "auto");
const OUT_FILE = path.join(AUTO_DIR, "auto.manifest.ts");

// Glob relativo a ROOT (evita líos Windows)
const ROUTES_GLOB = "src/routes/auto/**/*.routes.ts";

function toPosix(p) {
  return p.split(path.sep).join("/");
}

async function pathExists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function listRouteFiles() {
  const globMod = await import("glob");
  const globFn = globMod.glob ?? globMod.default ?? globMod;

  const files = await new Promise((resolve, reject) => {
    globFn(
      ROUTES_GLOB,
      {
        cwd: ROOT,
        nodir: true,
        ignore: ["**/auto.manifest.ts"],
      },
      (err, matches) => {
        if (err) return reject(err);
        resolve(matches || []);
      }
    );
  });

  return files
    .map((f) => toPosix(f))
    .filter((f) => f.endsWith(".routes.ts"))
    .sort((a, b) => a.localeCompare(b));
}

function makeEntryForFile(relFilePosix) {
  const prefix = "src/routes/auto/";
  let sub = relFilePosix.startsWith(prefix) ? relFilePosix.slice(prefix.length) : relFilePosix;
  sub = sub.replace(/\.ts$/i, "");
  const importPath = "./" + sub;
  const id = sub.replace(/[^\w/.-]/g, "_");
  return { id, importPath };
}

function renderManifestTs(entries) {
  const header = `/* eslint-disable */
// @generated by scripts/routes/genAutoRoutesManifest.mjs
// NO EDITAR A MANO. Editá los archivos *.routes.ts en src/routes/auto/

export type AutoRouteEntry = {
  /** basePath exportado por el módulo (ej: "/certificados") */
  basePath: string;
  /** loader dinámico al módulo .routes.ts */
  load: () => Promise<{ basePath: string; buildRouter: (ctx: any) => any }>;
};

`;

  const bodyLines = [];
  bodyLines.push(`export const manifest: AutoRouteEntry[] = [`);

  for (const e of entries) {
    bodyLines.push(`  {`);
    bodyLines.push(`    basePath: "",`);
    bodyLines.push(`    load: async () => (await import(${JSON.stringify(e.importPath)})) as any,`);
    bodyLines.push(`  },`);
  }

  bodyLines.push(`];`);
  bodyLines.push(``);
  bodyLines.push(`export const __manifestCount = manifest.length;`);
  bodyLines.push(``);

  return header + bodyLines.join("\n");
}

async function writeIfChanged(filePath, content) {
  const exists = await pathExists(filePath);
  if (exists) {
    const prev = await fs.readFile(filePath, "utf8");
    if (prev === content) return { changed: false };
  } else {
    await fs.mkdir(path.dirname(filePath), { recursive: true });
  }
  await fs.writeFile(filePath, content, "utf8");
  return { changed: true };
}

async function main() {
  await fs.mkdir(AUTO_DIR, { recursive: true });

  const files = await listRouteFiles();
  const entries = files.map(makeEntryForFile);

  const manifestTs = renderManifestTs(entries);
  await writeIfChanged(OUT_FILE, manifestTs);

  console.log(`[gen:routes] wrote ${toPosix(path.relative(ROOT, OUT_FILE))} (${entries.length} auto routes)`);

  if (process.env.DEBUG_GEN_ROUTES === "1") {
    console.log("Auto route files:");
    for (const f of files) console.log(" -", f);
  }
}

main().catch((err) => {
  console.error("[gen:routes] ERROR:", err);
  process.exit(1);
});
